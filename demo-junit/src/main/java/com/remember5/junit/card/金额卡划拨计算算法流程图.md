# 金额卡划拨计算算法流程图

## 算法概述

金额卡划拨计算算法用于计算每次消费时需要从留底资金划拨到可支用资金的金额。算法分为三个主要阶段：**记账阶段**、**留底阶段**和**最后一次划拨**。

## 主要流程图

```mermaid
flowchart TD
    Start([开始: calculate方法]) --> Validate[验证卡片有效性]
    
    Validate --> ValidateDetails{验证结果}
    ValidateDetails -->|验证失败| Error1[抛出异常:<br/>- 卡片对象为null<br/>- 卡片属性为null<br/>- 核销金额<0.01<br/>- 留底资金≤0]
    ValidateDetails -->|验证成功| CalcPlan[计算预计划拨金额<br/>planTransferAmount = 本次消费金额 × 划拨比例]
    
    CalcPlan --> CalcNew[计算新的累计数据:<br/>- newCumulativeAmount = 累计划拨 + 预计划拨<br/>- newCumulativeUsedEquity = 累计权益 + 本次消费]
    
    CalcNew --> CheckEquity{新的累计权益金额<br/>≤ 卡权益金额?}
    CheckEquity -->|否| Error2[抛出异常: 核销已超出总权益数]
    CheckEquity -->|是| CheckLast{是否最后一次划拨?<br/>newCumulativeUsedEquity == 卡权益金额}
    
    CheckLast -->|否| CheckMinAmount{预计划拨金额<br/>≥ 0.01?}
    CheckMinAmount -->|否| OnlyRecord[只做权益记录，不划拨<br/>返回 0.00]
    CheckMinAmount -->|是| GetActualAmount[获取实际划拨金额]
    
    CheckLast -->|是| DoLastTransfer[执行最后一次划拨]
    
    GetActualAmount --> CheckAvailable{新的累计划拨金额<br/>≤ 卡的初始可支用金额?}
    CheckAvailable -->|是| NotTransfer[【记账阶段】<br/>可支用资金充足，不划拨]
    CheckAvailable -->|否| RealTransfer[【留底阶段】<br/>需要动用留底资金]
    
    %% 记账阶段处理
    NotTransfer --> UpdateRecord1[更新累计划拨金额<br/>更新累计权益金额]
    UpdateRecord1 --> Return1[返回 0.00]
    
    %% 留底阶段处理
    RealTransfer --> CalcActual{是否已触发留底划拨?}
    CalcActual -->|是| UsePreplan[实际划拨金额 = 预计划拨金额]
    CalcActual -->|否| CalcDiff[实际划拨金额 = 新累计划拨 - 卡可支用金额<br/>设置触发留底划拨标志为true]
    
    UsePreplan --> CheckMinActual{实际划拨金额<br/>≥ 0.01?}
    CalcDiff --> CheckMinActual
    CheckMinActual -->|否| OnlyRecord2[只做权益记录，不划拨<br/>返回 0.00]
    CheckMinActual -->|是| UpdateAll[更新所有数据:<br/>- 累计权益金额<br/>- 累计划拨金额<br/>- 当前留底资金 -= 实际划拨金额]
    UpdateAll --> Return2[返回实际划拨金额]
    
    %% 最后一次划拨处理
    DoLastTransfer --> CalcLastPlan[计算最后划拨预计金额<br/>planAmount = 卡实收金额 - 累计划拨金额]
    CalcLastPlan --> CheckLastAmount{预计划拨金额<br/>≥ 卡初始留底资金?}
    
    CheckLastAmount -->|是| UseAllReserve[实际划拨金额 = 卡初始留底资金<br/>更新权益为剩余所有权益<br/>更新划拨为剩余所有金额]
    CheckLastAmount -->|否| UsePlan[实际划拨金额 = 预计划拨金额<br/>更新权益为本次消费金额<br/>更新划拨为预计划拨金额]
    
    UseAllReserve --> SetZeroReserve[设置当前留底资金 = 0]
    UsePlan --> SetZeroReserve
    SetZeroReserve --> Return3[返回实际划拨金额]
    
    %% 结束节点
    Return1 --> End([结束])
    Return2 --> End
    Return3 --> End
    OnlyRecord --> End
    OnlyRecord2 --> End
    Error1 --> End
    Error2 --> End
    
    %% 样式定义
    classDef processClass fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef decisionClass fill:#f3e5f5,stroke:#4a148c,stroke-width:2px  
    classDef errorClass fill:#ffebee,stroke:#b71c1c,stroke-width:2px
    classDef startEndClass fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef recordClass fill:#fff8e1,stroke:#ff8f00,stroke-width:2px
    
    class Start,End startEndClass
    class Validate,CalcPlan,CalcNew,GetActualAmount,NotTransfer,RealTransfer,DoLastTransfer,CalcLastPlan processClass
    class ValidateDetails,CheckEquity,CheckLast,CheckMinAmount,CheckAvailable,CalcActual,CheckMinActual,CheckLastAmount decisionClass
    class Error1,Error2 errorClass
    class UpdateRecord1,UpdateAll,OnlyRecord,OnlyRecord2,UseAllReserve,UsePlan,SetZeroReserve recordClass
```

## 关键决策点说明

### 1. 验证阶段
- **卡片对象验证**：确保卡片对象及关键属性不为null
- **金额验证**：核销金额必须≥0.01，留底资金必须>0
- **权益验证**：新的累计权益不能超过卡的总权益金额

### 2. 划拨模式判断
- **最后一次划拨**：当新的累计权益金额等于卡权益金额时
- **记账阶段**：新的累计划拨金额≤卡的初始可支用金额
- **留底阶段**：新的累计划拨金额>卡的初始可支用金额，需要动用留底资金

### 3. 三种处理模式

#### 记账阶段 (notTransfer)
- **条件**：可支用资金充足
- **处理**：只更新记账数据，不实际划拨资金
- **返回**：0.00

#### 留底阶段 (realTransfer) 
- **条件**：可支用资金不足，需要动用留底
- **处理逻辑**：
  - 首次触发：实际划拨 = 新累计划拨 - 卡可支用金额
  - 后续触发：实际划拨 = 预计划拨金额
- **最小金额检查**：实际划拨金额必须≥0.01
- **资金更新**：从当前留底资金中扣除实际划拨金额

#### 最后一次划拨 (doLastTransfer)
- **条件**：累计权益金额达到卡权益金额上限
- **处理逻辑**：
  - 预计划拨 ≥ 卡初始留底：划拨所有留底资金，更新所有剩余权益
  - 预计划拨 < 卡初始留底：按预计金额划拨，正常更新权益
- **最终状态**：当前留底资金设置为0

## 算法特点

1. **分阶段处理**：根据资金使用情况分为记账和留底两个阶段
2. **精确控制**：确保划拨金额不小于0.01元的最小单位
3. **权益保护**：严格控制累计权益不超过卡片权益上限
4. **资金安全**：留底资金逐步释放，确保资金安全
5. **状态追踪**：通过触发标志追踪留底划拨状态

## 测试用例分析

根据测试代码中的数据：
- **卡片配置**：权益金额10元，可支用金额9.98元，留底资金0.7元，划拨比例70%
- **正常场景**：包含单次大额消费、多次小额消费、边界金额等情况
- **异常场景**：包含超限消费、零金额消费、极小金额消费等情况

该算法通过严格的验证和分阶段处理，确保了金额卡划拨的准确性和安全性。
